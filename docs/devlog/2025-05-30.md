#  ğŸ“ Measurement

At this stage of the project, the focus shifts toward measurement â€” both in terms of functional correctness and performance.

## ğŸ¯ Measurement Goals

### 1ï¸âƒ£ Functional Correctness

- Q: Are the promised features working?
- Q: Have we accidentally broken anything (regressions)?

### 2ï¸âƒ£ Performance

- Q: What are the critical bottlenecks affecting the perception of product quality?
- Q: Why are users not staying on the platform?

## ğŸ› ï¸ Current Context

At this stage, the project reflects what youâ€™d expect from a small engineering team (< 5 engineers).
Speed of development is prioritized over polish â€” technical debt is expected.

As the product matures toward POC â†’ MVP â†’ first users, the ability to fix issues quickly becomes critical.

## ğŸ¨ Testing Philosophy

Maximize value for effort:

- Focus on testing public interfaces (REST APIs) only.
- No need to test internal functions or database internals at this stage.
- The current test environment will consist of:
  - The service container
  - The Postgres container

## ğŸ“Š Metrics Philosophy

Performance issues often affect users without being outright bugs:

- Queries per second spikes.
- Unreasonably Slow APIs. (P99 > 500ms)
- Increasing error rates under load.
- Underprovisioning.

We want to intentionally clamp down on metrics and thresholds. The only value is improving focus. Too many metrics
and ambitious thresholds can do the opposite. Metrics should guide data-driven insights:

- How many user queries does the system receive every second?
- Whatâ€™s the slowest query?
- Which services are resource starved?
  - Which resources are these?
- What should we optimize first?

## ğŸ† Summary

- ğŸ¯ Focus: Functional correctness and performance
- ğŸ§  Strategy: Integration tests against public REST APIs
- ğŸ¥… Goal: Visualize
- ğŸ’° Tradeoff: Some technical debt is acceptable. Priority is moving fast, recording bugs, measuring performance,
     preventing regressions and deliberate optimizations.
